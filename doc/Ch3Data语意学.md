```
class X {};
class Y : pubilc virtual X {};
class Z : pubilc virtual X {};
class A : pubilc Y, pubilc Z {};

sizeof(X) = 1
sizeof(Y) = 8
sizeof(Z) = 8
sizeof(A) = 12
```

一个空的类它有一个隐藏的1 byte大小，那是被编译前插进去的一个char。这使得这一class的两个对象得以在内存中配置独一无二的地址。

影响类大小的因素：
1. **语言本身造成的额外负担**
2. **编译器对于特殊情况所提供的优化处理**
3. **数据对其的限制**

一个虚基类的子类只会在派生类中存在一份实例，不管它在类继承体系中出现了多少次，一个class A的大小由下列几点决定：
1. 被大家共享的唯一一个class A实例，大小为1 byte。
2. 基类Y的大小，减去“因虚基类X而配置”的大小，结果是4byte。基类Z的算法相同。加起来是8 byte。
3. class A自己的大小：0 byte。
4. class A的补齐数量。前三项总和调整前大小为9 byte。class A必须调整至4 byte边界，所以要填补3 byte。结果是12 byte。

在程序之中，不管该class被产生出多少个对象，静态成员变量永远只存在一份实例，即使该类没有任何实例对象，其静态成员变量也存在。

每一个类对象因此必须有足够大的大小以容纳他的所有非静态成员变量。有时候其值可能令你吃惊，因为它可能比你想得还大：
1. 由编译器自动加上额外的成员变量，用以支持某些语言特性。
2. 因为边界调整的需要。
   
# 3.1 数据成员的绑定

对成员函数本体的分析，会直到整个类的声明都出现了才开始。因此在一个内联成员函数躯体之内的一个数据成员绑定操作，会在整个类声明完成之后才发生。

**总是把需要别名声明放在类的起始处**
 
# 3.2 数据成员的布局

非静态成员在类对象中的排列顺序将和其声明的顺序一样，任何中间介入的静态数据成员都不会被放进对象布局之中。

C++标准要求，在同一个访问部分（也就是private、pubilc、protect）中，数据成员的排列只需要符合“较晚出现数据成员在类对象中拥有较高地址”这一条件即可。

# 3.2 数据成员的存取

**静态数据成员**

每一个静态数据成员只有一个实例，存放在程序的数据段之中。