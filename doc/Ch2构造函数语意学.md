# 2.1 默认构造函数的构造操作

默认构造函数在需要的时候被编译器产生出来。

**带有“默认构造函数的”类成员对象**

如果一个类中没有任何构造函数，但它含一个类成员对象，而且带有默认构造函数，那么这个类的隐式默认构造函数就是必须的，编译器需要为该类合成出一个默认构造函数。不过这个合成操作只有构造函数真正需要被调用时才会发生。

**带有默认构造函数的基类**

类似的道理，如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么这个派生类的默认构造函数会被视为有用的，因此需要被合成出来。

**带有一个虚函数的类**

另外有两种情况，也需要合成出默认构造函数：
1. 类声明或继承一个虚函数。
2. 类派生自一个继承串链，其中有一个或更多的虚基类。

不管哪一种情况，由于缺乏由用户声明的构造函数，编译器会详细记录合成的一个默认构造函数的必要信息。

**带有一个虚基类的类**

虚基类的实现法在不同的编译器之间有极大的差异，然而，每一种实现法的共同点在于必须是虚基类在其每一个派生类对象中的位置，能够于执行期准备妥当。对于类所定义的每一个构造函数，编译器会安插那些允许每一个虚基类的执行期存取操作的代码。如果没有声明任何构造函数，编译器需要合成一个。

**总结：**

在合成的默认构造函数中，只有基类的子对象和成员类对象会被初始化，所有其他的非静态数据成员都不会被初始化。

C++新手一般有两个常见的误解：
1. 任何类如果没有定义默认构造函数，就会被合成出来一个。
2. 编译器合成出来的默认构造函数会显式设定类内每一个数据成员的默认值。

# 2.2 拷贝构造函数的构造操作

有三种情况，会以一个对象的内用作为另一个对象的初值。

**默认对每一个成员初始化**

当类对象以“相同类的另一个对象”作为初值，其内部是以所谓的默认一个个初始化变量（就是把每一个内建或者派生的数据成员的值，从某个对象拷贝一份到另外一个对象身上）手法完成的。不过它并不会拷贝i其中的类成员对象，而是以递归的方式对每一个成员进行初始化。

决定一个拷贝构造函数是否为没用的标准在一类是否展现出所谓的“位逐次拷贝”

**位逐次拷贝**

```
Word noun("book");
void foo()
{
    Word verb = noun;
}
```
```
class Word {
public:
    Word(const char*);
    ~Word() {delete []str;}
    // ...
private:
    int cnt;
    char *str;
};
```
这种情况下并不需要合成出一个默认拷贝构造函数，因为上述声明展现了位逐次拷贝,而verb的初始化操作也就不需要以一个函数调用收场。然而如果class Word是这样声明的：
```
class Word {
public:
    Word(const String&);
    ~Word() {delete []str;}
    // ...
private:
    int cnt;
    String *str;
};
```
其中String声明了一个隐式的拷贝构造函数：
```
class String {
public:
    String(const char*);
    String(const String&);
    ~String();
    // ...
};
```
这种情况下，编译器必须合成出一个拷贝构造函数，一边调用成员类String对象的拷贝构造函数。

**不要位逐次拷贝**

什么时候类不展现出位逐次拷贝，有四种情况：
1. 当类内汗一个成员对象而后者的类声明中有一个拷贝构造函数时。
2. 当类继承自一个基类而后者存在一个拷贝构造函数时。
3. 当类声明了一个或多个虚函数时。
4. 当类派生自一个继承串链，其中有一个或者多个虚基类时。

**重新设定虚函数表的指针**

编译期间的两个程序扩张操作：
1. 增加一个虚函数表，内含每一个有作用的虚函数地址。
2. 一个指向虚函数表的指针(vptr)，安插在每一个类对象内。

如果编译器对每一个先产生的类对象的vptr不能成功而正确地设好其初值，将导致可怕的后果。因此，当编译器导入一个vptr到类之中时，该类就不能再展现位逐次拷贝了，现在编译器需要合成出一个拷贝构造函数以求将vptr适当地初始化。

**处理虚基类的子对象**

虚基类的存在需要特别处理。一个类对象如果以另一个对象作为初值，而后者有一个虚基类子对象，那么也会使位逐次拷贝失效。

# 2.3 程序转化语意学

**显示的初始化操作**

**参数的初始化**

**返回值的初始化**

**在使用者层面做优化**

**在编译器层面做优化**

**拷贝构造函数：要还是不要？**

拷贝构造函数的应用，迫使编译器多多少少对你的程序代码做部分转化。尤其是当一个函数以传值的方式传回一个类对象，而该类有一个拷贝构造函数时。这将导致深奥的程序转化——不论在函数的定义上还是在使用上。此外，编译器也将拷贝构造函数的调用操作优化，以一个额外的第一参数取代NRV(Name Return Value)。

# 2.4 成员们的初始化队伍

当写下一个构造函数时，就有机会设定类成员的初值。要是不经过成员初始化表，就是在构造函数本体之内。在下列情况下，为了让你的程序能够被顺利编译，你必须使用成员初始化列表：
1. 当初始化一个引用成员时；
2. 当初始化一个const成员时；
3. 当调用一个基类的构造函数，而它拥有一组参数时；
4. 当调用一个成员类的构造函数，而它拥有一组参数时。

编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前。

初始化列表中的项目顺势是由class中的成员声明顺序决定的，不是由初始化列表中的排列顺序决定的。

初始化列表的项目被放在显示的用户代码之前。